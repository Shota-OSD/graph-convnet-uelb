======================================================================
Reachability Mask の提案分析
======================================================================

🎯 Reachability Mask とは？

各ステップで「目的地に到達可能なノード」のみを選択肢として残す仕組み。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 現在の問題:

問題1: 目的地に到達できないパスが18%
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Complete Rate: 82%
  → 18%のコモディティが目的地に到達できない
  
  原因:
    - モデルが「行き止まり」に誘導される
    - 到達不可能なノードを選んでしまう
    - ループを避けようとして詰む

問題2: ペナルティでは解決できない
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ペナルティ強化の結果:
    - 2.5倍強化: Complete Rate 82% → 82%（変化なし）
    - モデルは「どう避けるか」を学習できていない
  
  理由:
    - サンプリング時に既に到達不可能な選択をしている
    - 事後のペナルティでは手遅れ

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 Reachability Mask の解決策:

コンセプト:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  「目的地に到達できないノードは選択肢から除外する」
  
  実装:
    1. 現在のノードから目的地への経路が存在するか確認
    2. 経路がないノードはマスク（確率0）
    3. 経路があるノードのみサンプリング対象

効果:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ✅ Complete Rate: 82% → 100%（理論上）
  ✅ 不完全パスが根本的に消える
  ✅ ペナルティ不要（構造的に保証）
  ✅ 学習が安定化（失敗が減る）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🔧 実装方法:

オプションA: 動的Reachability（各ステップで計算）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PathSampler._sample_single_path() 内で実装

```python
def _is_reachable(current_node, target_node, visited, graph):
    """BFS/DFSで到達可能性をチェック"""
    if current_node == target_node:
        return True
    
    # 訪問済みノードを除外したグラフでBFS
    queue = [current_node]
    explored = set(visited)
    
    while queue:
        node = queue.pop(0)
        if node == target_node:
            return True
        
        for neighbor in graph[node]:
            if neighbor not in explored:
                explored.add(neighbor)
                queue.append(neighbor)
    
    return False
```

```python
# サンプリング時にマスクを適用
for next_node in range(num_nodes):
    if next_node in visited:
        mask[next_node] = False  # 既存
    elif not _is_reachable(next_node, dst, visited + [next_node], graph):
        mask[next_node] = False  # 新規: 到達不可能ノードをマスク
```

長所:
  ✅ 正確（現在の状態を反映）
  ✅ 必ず目的地に到達可能

短所:
  ❌ 計算コスト高（各ステップでBFS）
  ❌ 訓練が遅くなる可能性

オプションB: 事前計算Reachability（グラフ全体で計算）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
初期化時に全ペアの到達可能性を計算

```python
def precompute_reachability(graph):
    """全ノードペアの到達可能性を事前計算"""
    n = len(graph)
    reachable = np.zeros((n, n), dtype=bool)
    
    for src in range(n):
        # srcから到達可能なノードをBFS
        queue = [src]
        visited = {src}
        
        while queue:
            node = queue.pop(0)
            reachable[src][node] = True
            
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
    
    return reachable
```

```python
# サンプリング時に参照
if not reachability_matrix[next_node][dst]:
    mask[next_node] = False
```

長所:
  ✅ 高速（O(1)で参照）
  ✅ 訓練速度に影響なし

短所:
  ❌ 訪問済みノードを考慮しない
  ❌ やや不正確（保守的すぎる可能性）

オプションC: ハイブリッド
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  - 基本: 事前計算で粗くフィルタ
  - 重要なケース: 動的計算で精密に

長所:
  ✅ バランスが良い
  ✅ ほとんどのケースで高速

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 期待される効果:

【現在】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Complete Rate: 82%
平均報酬: 1.48（ペナルティなし）、-1.55（ペナルティ2.5倍）

推定内訳:
  - 完全成功: 40% × 9.0 = 3.6
  - 1パス失敗: 40% × (-3.0) = -1.2
  - 2+パス失敗: 20% × (-7.5) = -1.5
  合計: 0.9

【Reachability Mask導入後】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Complete Rate: 95~100%（理論上100%）

推定内訳（95%の場合）:
  - 完全成功: 95% × 9.0 = 8.55
  - 1パス失敗: 5% × (-3.0) = -0.15
  合計: 8.4 ← 目標の7~9に到達！

改善幅:
  Complete Rate: 82% → 95~100% (+13~18%)
  平均報酬: 0.9 → 8.4 (+7.5、約8倍！)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️  潜在的な問題:

問題1: 探索の制限
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Reachability Maskは「確実に到達可能」な経路のみ
  → 最適でない経路を選ぶ可能性がある
  
  対策:
    - Load Factorの最適化は依然としてモデルが学習
    - Maskは「到達可能性」のみ保証
    - 経路の品質はモデルに任せる

問題2: 計算コスト
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  動的計算の場合、各ステップでBFS
  → 訓練時間が増加する可能性
  
  対策:
    - オプションB（事前計算）を使用
    - または軽量なヒューリスティック

問題3: 完全パス保証で学習シグナルが弱まる
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  全パスが完全になると、報酬の差がLoad Factorのみ
  → 学習シグナルが弱くなる可能性
  
  対策:
    - これは望ましい状況！
    - Load Factor最適化に集中できる
    - エントロピーボーナスで探索を維持

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 推奨実装:

ステップ1: オプションB（事前計算）で試す
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  理由:
    - 実装が簡単
    - 計算コストが低い
    - 効果を素早く確認できる
  
  実装場所:
    - PathSampler.__init__() で事前計算
    - PathSampler._sample_single_path() でマスク適用

ステップ2: 効果を確認
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  期待結果:
    - Complete Rate: 95~100%
    - 平均報酬: 7~9
  
  もし不十分なら:
    - オプションA（動的計算）を試す

ステップ3: ペナルティを元に戻す
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Reachability Maskで構造的に保証されるため、
  ペナルティは元の値（-2/-5/-10）で十分

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 結論:

Reachability Maskは「根本的な解決策」
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Complete Rateを構造的に保証
✅ ペナルティ調整不要
✅ 学習が安定化
✅ 報酬を大幅に改善（8倍）

vs ペナルティ調整（対症療法）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️  効果が限定的
⚠️  バランス調整が難しい
⚠️  根本解決にならない

推奨: Reachability Maskを実装してください！
これにより、問題の82%が構造的に解決されます。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 実装結果 (2025-10-22 00:47:43)

実装内容:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ オプションB（事前計算Reachability）を実装
✅ PathSampler.__init__() で全ペアの到達可能性をBFSで事前計算
✅ _sample_single_path() でreachability maskを適用
✅ ε-greedy探索にもreachability制約を追加
✅ ペナルティを元の値に戻す (-2/-5/-10)

実装ファイル:
  - src/gcn/algorithms/path_sampler.py (Reachability計算とマスク適用)
  - src/gcn/training/reinforcement_strategy.py (ペナルティ復元)

実験結果:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【基本メトリクス】
┌─────────────────────────┬─────────┬─────────┬──────────┐
│ メトリクス              │ 実装前  │ 実装後  │ 変化     │
├─────────────────────────┼─────────┼─────────┼──────────┤
│ Complete Rate          │ 82%     │ 83%     │ +1%      │
│ Avg Reward (最終)      │ 1.48    │ 1.97    │ +0.49    │
│ Capacity Violation     │ 2%      │ 0%      │ ✅ 解消  │
│ Val Approx Rate        │ 74.04%  │ 74.04%  │ 変化なし │
│ Test Approx Rate       │ 67.06%  │ 67.06%  │ 変化なし │
└─────────────────────────┴─────────┴─────────┴──────────┘

【詳細メトリクス (Epoch 1-25)】
┌──────────────────┬─────────┬─────────┬─────────┬──────────┐
│ メトリクス       │ Min     │ Max     │ Avg     │ 最終値   │
├──────────────────┼─────────┼─────────┼─────────┼──────────┤
│ Reward           │ 0.57    │ 2.36    │ 1.44    │ 1.97     │
│ Complete%        │ 79.4%   │ 84.6%   │ 81.8%   │ 83.0%    │
│ Entropy          │ 0.053   │ 0.140   │ 0.087   │ 0.106    │
│ Avg Path Length  │ 6.20    │ 6.61    │ 6.42    │ 6.42     │
│ Load Factor      │ 0.337   │ 0.366   │ 0.350   │ 0.361    │
└──────────────────┴─────────┴─────────┴─────────┴──────────┘

分析:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

❌ **期待していた大幅改善は見られなかった**

1️⃣ Complete Rate改善が限定的 (+1%のみ)
   期待: 82% → 95-100%
   実際: 82% → 83%

   原因の推測:
   ✓ グラフ構造上、ほとんどのノードペアが既に到達可能
   ✓ 残りの17%の未到達は「構造的な到達不可能」ではない
   ✓ 問題は別の要因（容量制約、学習不足、探索不足）

2️⃣ 報酬の変動が大きい（不安定な学習）
   最高値: 2.36 (Epoch 12)
   最低値: 0.57 (Epoch 21)
   最終値: 1.97 (Epoch 25)

   → 学習が収束していない

3️⃣ Capacity Violation = 0% は改善
   実装前: 2%
   実装後: 0%

   → Reachability Maskが間接的に容量制約も改善

4️⃣ エントロピーが低め (0.053-0.140)
   目標範囲: 0.05-0.15

   → 探索が不足している可能性

根本原因の再分析:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

❗ Reachability Maskの前提が誤っていた可能性

仮説1: 「残容量を考慮していない」
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  現在の実装:
    - edges_capacity > 0 のみをチェック
    - 実際の残容量（dynamic capacity）は考慮していない

  問題:
    - グラフ上は到達可能でも、容量不足で詰まる
    - 他のコモディティが使い切った経路は使えない

  17%の未到達の真の原因:
    ❌ 構造的な到達不可能性（グラフに経路がない）
    ✅ 動的な詰まり（容量不足、他のパスの干渉）

仮説2: 「学習エポックが不足」
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  報酬の変動パターン:
    - Epoch 1-6:  1.0-1.7（初期探索）
    - Epoch 12-15: 2.0-2.4（一時的な改善）
    - Epoch 21:    0.57（大幅悪化）
    - Epoch 25:    1.97（回復）

  → 学習が安定していない
  → 25エポックでは不十分

仮説3: 「探索と活用のバランス」
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  現在の設定:
    - entropy_weight: 0.1
    - entropy_epsilon: 0.05
    - entropy範囲: 0.053-0.140

  問題:
    - 探索が不足している可能性
    - モデルが局所最適解に陥っている

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 次のアクション候補:

オプション1: エポック数を35に増やす
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  理由:
    ✓ 報酬の変動が大きく、学習が収束していない
    ✓ Epoch 12-15で良い結果が出ている（2.0-2.4）
    ✓ より多くのエポックで安定化する可能性

  期待効果:
    - Complete Rate: 83% → 85-90%
    - Avg Reward: 1.97 → 2.5-3.5

  実装工数: 小（設定変更のみ）

オプション2: 動的Reachability Mask（残容量考慮）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  理由:
    ✓ 現在の静的maskでは容量制約を考慮していない
    ✓ 17%の未到達は「動的な詰まり」の可能性

  実装:
    - サンプリング中の残容量を追跡
    - 容量不足の経路をマスク

  期待効果:
    - Complete Rate: 83% → 90-95%
    - Avg Reward: 1.97 → 4.0-6.0

  実装工数: 中（PathSamplerの大幅修正）

オプション3: 探索強化（entropy調整）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  理由:
    ✓ エントロピーが低め（0.053-0.140）
    ✓ モデルが局所最適解に陥っている可能性

  実装:
    - entropy_weight: 0.1 → 0.15
    - または entropy_epsilon: 0.05 → 0.10

  期待効果:
    - より広い探索
    - 異なる経路の発見

  実装工数: 小（設定変更のみ）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 結論:

Reachability Maskは実装されたが、効果は限定的（+1%）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Capacity Violation 0%達成（副次的効果）
❌ Complete Rate大幅改善せず（82% → 83%）
❌ 報酬目標未達（目標7-9、実際1.97）

根本原因は「構造的到達不可能性」ではなく:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 動的な容量制約（残容量の考慮不足）
2. 学習の不安定性（エポック不足）
3. 探索不足（エントロピーが低い）

推奨される次のステップ:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1️⃣ まず: エポック数35で再実験（学習安定化を確認）
2️⃣ 次に: 結果に応じて動的Reachability Maskまたは探索強化を検討
